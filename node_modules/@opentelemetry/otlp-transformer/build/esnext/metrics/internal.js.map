{"version":3,"file":"internal.js","sourceRoot":"","sources":["../../../src/metrics/internal.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ValueType } from '@opentelemetry/api';\nimport { hrTimeToNanoseconds } from '@opentelemetry/core';\nimport {\n  AggregationTemporality,\n  DataPoint,\n  DataPointType,\n  ExponentialHistogram,\n  Histogram,\n  MetricData,\n  ResourceMetrics,\n  ScopeMetrics,\n} from '@opentelemetry/sdk-metrics';\nimport { toAttributes } from '../common/internal';\nimport {\n  EAggregationTemporality,\n  IExponentialHistogramDataPoint,\n  IHistogramDataPoint,\n  IMetric,\n  INumberDataPoint,\n  IResourceMetrics,\n  IScopeMetrics,\n} from './types';\n\nexport function toResourceMetrics(\n  resourceMetrics: ResourceMetrics\n): IResourceMetrics {\n  return {\n    resource: {\n      attributes: toAttributes(resourceMetrics.resource.attributes),\n      droppedAttributesCount: 0,\n    },\n    schemaUrl: undefined, // TODO: Schema Url does not exist yet in the SDK.\n    scopeMetrics: toScopeMetrics(resourceMetrics.scopeMetrics),\n  };\n}\n\nexport function toScopeMetrics(scopeMetrics: ScopeMetrics[]): IScopeMetrics[] {\n  return Array.from(\n    scopeMetrics.map(metrics => {\n      const scopeMetrics: IScopeMetrics = {\n        scope: {\n          name: metrics.scope.name,\n          version: metrics.scope.version,\n        },\n        metrics: metrics.metrics.map(metricData => toMetric(metricData)),\n        schemaUrl: metrics.scope.schemaUrl,\n      };\n      return scopeMetrics;\n    })\n  );\n}\n\nexport function toMetric(metricData: MetricData): IMetric {\n  const out: IMetric = {\n    name: metricData.descriptor.name,\n    description: metricData.descriptor.description,\n    unit: metricData.descriptor.unit,\n  };\n\n  const aggregationTemporality = toAggregationTemporality(\n    metricData.aggregationTemporality\n  );\n\n  if (metricData.dataPointType === DataPointType.SUM) {\n    out.sum = {\n      aggregationTemporality,\n      isMonotonic: metricData.isMonotonic,\n      dataPoints: toSingularDataPoints(metricData),\n    };\n  } else if (metricData.dataPointType === DataPointType.GAUGE) {\n    // Instrument is a gauge.\n    out.gauge = {\n      dataPoints: toSingularDataPoints(metricData),\n    };\n  } else if (metricData.dataPointType === DataPointType.HISTOGRAM) {\n    out.histogram = {\n      aggregationTemporality,\n      dataPoints: toHistogramDataPoints(metricData),\n    };\n  } else if (metricData.dataPointType === DataPointType.EXPONENTIAL_HISTOGRAM) {\n    out.exponentialHistogram = {\n      aggregationTemporality,\n      dataPoints: toExponentialHistogramDataPoints(metricData),\n    };\n  }\n\n  return out;\n}\n\nfunction toSingularDataPoint(\n  dataPoint:\n    | DataPoint<number>\n    | DataPoint<Histogram>\n    | DataPoint<ExponentialHistogram>,\n  valueType: ValueType\n) {\n  const out: INumberDataPoint = {\n    attributes: toAttributes(dataPoint.attributes),\n    startTimeUnixNano: hrTimeToNanoseconds(dataPoint.startTime),\n    timeUnixNano: hrTimeToNanoseconds(dataPoint.endTime),\n  };\n\n  if (valueType === ValueType.INT) {\n    out.asInt = dataPoint.value as number;\n  } else if (valueType === ValueType.DOUBLE) {\n    out.asDouble = dataPoint.value as number;\n  }\n\n  return out;\n}\n\nfunction toSingularDataPoints(metricData: MetricData): INumberDataPoint[] {\n  return metricData.dataPoints.map(dataPoint => {\n    return toSingularDataPoint(dataPoint, metricData.descriptor.valueType);\n  });\n}\n\nfunction toHistogramDataPoints(metricData: MetricData): IHistogramDataPoint[] {\n  return metricData.dataPoints.map(dataPoint => {\n    const histogram = dataPoint.value as Histogram;\n    return {\n      attributes: toAttributes(dataPoint.attributes),\n      bucketCounts: histogram.buckets.counts,\n      explicitBounds: histogram.buckets.boundaries,\n      count: histogram.count,\n      sum: histogram.sum,\n      min: histogram.min,\n      max: histogram.max,\n      startTimeUnixNano: hrTimeToNanoseconds(dataPoint.startTime),\n      timeUnixNano: hrTimeToNanoseconds(dataPoint.endTime),\n    };\n  });\n}\n\nfunction toExponentialHistogramDataPoints(\n  metricData: MetricData\n): IExponentialHistogramDataPoint[] {\n  return metricData.dataPoints.map(dataPoint => {\n    const histogram = dataPoint.value as ExponentialHistogram;\n    return {\n      attributes: toAttributes(dataPoint.attributes),\n      count: histogram.count,\n      min: histogram.min,\n      max: histogram.max,\n      sum: histogram.sum,\n      positive: {\n        offset: histogram.positive.offset,\n        bucketCounts: histogram.positive.bucketCounts,\n      },\n      negative: {\n        offset: histogram.negative.offset,\n        bucketCounts: histogram.negative.bucketCounts,\n      },\n      scale: histogram.scale,\n      zeroCount: histogram.zeroCount,\n      startTimeUnixNano: hrTimeToNanoseconds(dataPoint.startTime),\n      timeUnixNano: hrTimeToNanoseconds(dataPoint.endTime),\n    };\n  });\n}\n\nfunction toAggregationTemporality(\n  temporality: AggregationTemporality\n): EAggregationTemporality {\n  if (temporality === AggregationTemporality.DELTA) {\n    return EAggregationTemporality.AGGREGATION_TEMPORALITY_DELTA;\n  }\n\n  if (temporality === AggregationTemporality.CUMULATIVE) {\n    return EAggregationTemporality.AGGREGATION_TEMPORALITY_CUMULATIVE;\n  }\n\n  return EAggregationTemporality.AGGREGATION_TEMPORALITY_UNSPECIFIED;\n}\n"]}