{"version":3,"file":"MetricReader.js","sourceRoot":"","sources":["../../../src/export/MetricReader.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;GAcG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEH,OAAO,KAAK,GAAG,MAAM,oBAAoB,CAAC;AAI1C,OAAO,EAAE,eAAe,EAAE,MAAM,UAAU,CAAC;AAQ3C,OAAO,EAGL,4BAA4B,EAC5B,wCAAwC,GACzC,MAAM,uBAAuB,CAAC;AAgB/B;;;GAGG;AACH;IASE,sBAAY,OAA6B;;QARzC,6BAA6B;QAC7B,yFAAyF;QACjF,cAAS,GAAG,KAAK,CAAC;QAOxB,IAAI,CAAC,oBAAoB;YACvB,MAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,mBAAmB,mCAAI,4BAA4B,CAAC;QAC/D,IAAI,CAAC,+BAA+B;YAClC,MAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,8BAA8B,mCACvC,wCAAwC,CAAC;IAC7C,CAAC;IAED;;;;OAIG;IACH,wCAAiB,GAAjB,UAAkB,cAA8B;QAC9C,IAAI,IAAI,CAAC,eAAe,EAAE;YACxB,MAAM,IAAI,KAAK,CACb,yDAAyD,CAC1D,CAAC;SACH;QACD,IAAI,CAAC,eAAe,GAAG,cAAc,CAAC;QACtC,IAAI,CAAC,aAAa,EAAE,CAAC;IACvB,CAAC;IAED;;;OAGG;IACH,wCAAiB,GAAjB,UAAkB,cAA8B;QAC9C,OAAO,IAAI,CAAC,oBAAoB,CAAC,cAAc,CAAC,CAAC;IACnD,CAAC;IAED;;;OAGG;IACH,mDAA4B,GAA5B,UACE,cAA8B;QAE9B,OAAO,IAAI,CAAC,+BAA+B,CAAC,cAAc,CAAC,CAAC;IAC9D,CAAC;IAED;;;OAGG;IACO,oCAAa,GAAvB;QACE,mCAAmC;IACrC,CAAC;IAmBD;;OAEG;IACG,8BAAO,GAAb,UAAc,OAA2B;;;gBACvC,IAAI,IAAI,CAAC,eAAe,KAAK,SAAS,EAAE;oBACtC,MAAM,IAAI,KAAK,CAAC,+CAA+C,CAAC,CAAC;iBAClE;gBAED,sGAAsG;gBACtG,IAAI,IAAI,CAAC,SAAS,EAAE;oBAClB,MAAM,IAAI,KAAK,CAAC,0BAA0B,CAAC,CAAC;iBAC7C;gBAED,sBAAO,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC;wBAClC,aAAa,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,aAAa;qBACtC,CAAC,EAAC;;;KACJ;IAED;;;;;OAKG;IACG,+BAAQ,GAAd,UAAe,OAAyB;;;;;wBACtC,4DAA4D;wBAC5D,IAAI,IAAI,CAAC,SAAS,EAAE;4BAClB,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,6BAA6B,CAAC,CAAC;4BAC9C,sBAAO;yBACR;6BAGG,CAAA,CAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,aAAa,KAAI,IAAI,CAAA,EAA9B,wBAA8B;wBAChC,qBAAM,IAAI,CAAC,UAAU,EAAE,EAAA;;wBAAvB,SAAuB,CAAC;;4BAExB,qBAAM,eAAe,CAAC,IAAI,CAAC,UAAU,EAAE,EAAE,OAAO,CAAC,aAAa,CAAC,EAAA;;wBAA/D,SAA+D,CAAC;;;wBAGlE,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;;;;;KACvB;IAED;;;;;OAKG;IACG,iCAAU,GAAhB,UAAiB,OAA2B;;;;;wBAC1C,IAAI,IAAI,CAAC,SAAS,EAAE;4BAClB,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,qDAAqD,CAAC,CAAC;4BACrE,sBAAO;yBACR;6BAGG,CAAA,CAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,aAAa,KAAI,IAAI,CAAA,EAA9B,wBAA8B;wBAChC,qBAAM,IAAI,CAAC,YAAY,EAAE,EAAA;;wBAAzB,SAAyB,CAAC;wBAC1B,sBAAO;4BAGT,qBAAM,eAAe,CAAC,IAAI,CAAC,YAAY,EAAE,EAAE,OAAO,CAAC,aAAa,CAAC,EAAA;;wBAAjE,SAAiE,CAAC;;;;;KACnE;IACH,mBAAC;AAAD,CAAC,AAxID,IAwIC","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '@opentelemetry/api';\nimport { AggregationTemporality } from './AggregationTemporality';\nimport { MetricProducer } from './MetricProducer';\nimport { CollectionResult } from './MetricData';\nimport { callWithTimeout } from '../utils';\nimport { InstrumentType } from '../InstrumentDescriptor';\nimport {\n  CollectionOptions,\n  ForceFlushOptions,\n  ShutdownOptions,\n} from '../types';\nimport { Aggregation } from '../view/Aggregation';\nimport {\n  AggregationSelector,\n  AggregationTemporalitySelector,\n  DEFAULT_AGGREGATION_SELECTOR,\n  DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR,\n} from './AggregationSelector';\n\nexport interface MetricReaderOptions {\n  /**\n   * Aggregation selector based on metric instrument types. If no views are\n   * configured for a metric instrument, a per-metric-reader aggregation is\n   * selected with this selector.\n   */\n  aggregationSelector?: AggregationSelector;\n  /**\n   * Aggregation temporality selector based on metric instrument types. If\n   * not configured, cumulative is used for all instruments.\n   */\n  aggregationTemporalitySelector?: AggregationTemporalitySelector;\n}\n\n/**\n * A registered reader of metrics that, when linked to a {@link MetricProducer}, offers global\n * control over metrics.\n */\nexport abstract class MetricReader {\n  // Tracks the shutdown state.\n  // TODO: use BindOncePromise here once a new version of @opentelemetry/core is available.\n  private _shutdown = false;\n  // MetricProducer used by this instance.\n  private _metricProducer?: MetricProducer;\n  private readonly _aggregationTemporalitySelector: AggregationTemporalitySelector;\n  private readonly _aggregationSelector: AggregationSelector;\n\n  constructor(options?: MetricReaderOptions) {\n    this._aggregationSelector =\n      options?.aggregationSelector ?? DEFAULT_AGGREGATION_SELECTOR;\n    this._aggregationTemporalitySelector =\n      options?.aggregationTemporalitySelector ??\n      DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR;\n  }\n\n  /**\n   * Set the {@link MetricProducer} used by this instance.\n   *\n   * @param metricProducer\n   */\n  setMetricProducer(metricProducer: MetricProducer) {\n    if (this._metricProducer) {\n      throw new Error(\n        'MetricReader can not be bound to a MeterProvider again.'\n      );\n    }\n    this._metricProducer = metricProducer;\n    this.onInitialized();\n  }\n\n  /**\n   * Select the {@link Aggregation} for the given {@link InstrumentType} for this\n   * reader.\n   */\n  selectAggregation(instrumentType: InstrumentType): Aggregation {\n    return this._aggregationSelector(instrumentType);\n  }\n\n  /**\n   * Select the {@link AggregationTemporality} for the given\n   * {@link InstrumentType} for this reader.\n   */\n  selectAggregationTemporality(\n    instrumentType: InstrumentType\n  ): AggregationTemporality {\n    return this._aggregationTemporalitySelector(instrumentType);\n  }\n\n  /**\n   * Handle once the SDK has initialized this {@link MetricReader}\n   * Overriding this method is optional.\n   */\n  protected onInitialized(): void {\n    // Default implementation is empty.\n  }\n\n  /**\n   * Handle a shutdown signal by the SDK.\n   *\n   * <p> For push exporters, this should shut down any intervals and close any open connections.\n   * @protected\n   */\n  protected abstract onShutdown(): Promise<void>;\n\n  /**\n   * Handle a force flush signal by the SDK.\n   *\n   * <p> In all scenarios metrics should be collected via {@link collect()}.\n   * <p> For push exporters, this should collect and report metrics.\n   * @protected\n   */\n  protected abstract onForceFlush(): Promise<void>;\n\n  /**\n   * Collect all metrics from the associated {@link MetricProducer}\n   */\n  async collect(options?: CollectionOptions): Promise<CollectionResult> {\n    if (this._metricProducer === undefined) {\n      throw new Error('MetricReader is not bound to a MetricProducer');\n    }\n\n    // Subsequent invocations to collect are not allowed. SDKs SHOULD return some failure for these calls.\n    if (this._shutdown) {\n      throw new Error('MetricReader is shutdown');\n    }\n\n    return this._metricProducer.collect({\n      timeoutMillis: options?.timeoutMillis,\n    });\n  }\n\n  /**\n   * Shuts down the metric reader, the promise will reject after the optional timeout or resolve after completion.\n   *\n   * <p> NOTE: this operation will continue even after the promise rejects due to a timeout.\n   * @param options options with timeout.\n   */\n  async shutdown(options?: ShutdownOptions): Promise<void> {\n    // Do not call shutdown again if it has already been called.\n    if (this._shutdown) {\n      api.diag.error('Cannot call shutdown twice.');\n      return;\n    }\n\n    // No timeout if timeoutMillis is undefined or null.\n    if (options?.timeoutMillis == null) {\n      await this.onShutdown();\n    } else {\n      await callWithTimeout(this.onShutdown(), options.timeoutMillis);\n    }\n\n    this._shutdown = true;\n  }\n\n  /**\n   * Flushes metrics read by this reader, the promise will reject after the optional timeout or resolve after completion.\n   *\n   * <p> NOTE: this operation will continue even after the promise rejects due to a timeout.\n   * @param options options with timeout.\n   */\n  async forceFlush(options?: ForceFlushOptions): Promise<void> {\n    if (this._shutdown) {\n      api.diag.warn('Cannot forceFlush on already shutdown MetricReader.');\n      return;\n    }\n\n    // No timeout if timeoutMillis is undefined or null.\n    if (options?.timeoutMillis == null) {\n      await this.onForceFlush();\n      return;\n    }\n\n    await callWithTimeout(this.onForceFlush(), options.timeoutMillis);\n  }\n}\n"]}